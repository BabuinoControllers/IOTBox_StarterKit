
---------------------
OBject
---------------------

Donnecting with device
IOT Brick devices are plug and play devices. DO not need any configuration. Just power and plug the ethernet cable. There is no need to configure any IP address. IOT Brick uses DHCP protocol in order to agree witht he DHCP server an IP address adn the discovery protocol that allow to connect woth the device just by means of its serial number. So device serial number is crucial to estabilish a communication with the device.
Device serial number is an hex string of 16 bytes.

Everything is an Object
In IOT Brick all the data  functions are managed through objects. An object has a unique object identifier, an object type, object status that can be enabled and disabled and its onwn non volatile and volatile memory space. Object type defines a specific type of object and the set of data and methods relevant to the object.

If the object is disabled thatn it can not interact with users.

To interact with the objects on the device remote application mirrors device objects by using IOT brick library. 
By interacting with mirrored objects remote applicaiton can manage remote objects on the device without warrying about communication.

Devices are object itself.

	Device thisDevice = Device.discover(deviceSerialNumber, ConnectionDetails.BEARER_ETHERNET, 3, 2000);
Creates an instance of a device object by discovering the object over the ethernet bearer given its serial number.

Security
Communication protocol allow remote communication between objects in remote application: the remote objects and its mirror object into the device. Communication protocol enforces end to end security between users and the device by creating a secure tunnel between the two. Purpose of secure tunnel is enforce confidentiality, integrity and authenticaiton of origin of data.

 

---------------------
Users
---------------------
In IOT Brick Users have access to the resources, can read value of sensors and activates switch as well.
Access to resources is based on roles. There are three different roles for users.

- Super Administrators
- Administrators
- Users

Super Administrators have full access to device resources. Can instantiate or delete all objects including digital function blocks and define the application logic. Super administrators have access to device settings. There is only one super administrator per device. Super administrator can create new users and define weekly policy.
Super administrator can assign adinistrator priviledge to users and have full access to system logs.

Administrators can create new usesers, change user properties, enable/disable users define weekly policy and associate to users. Administrators can not modify the setting 

Users have access to resources like sensors or can control switches based on the policy defined by super administrators and adimistrators.

When user is instantiated it is defined its role and an initial key.

Examples
	User admin = new User(superA, User.USER_ROLE_ADMIN, "initial key");
Remote application instantiate a new user in the device. User have the administrator role and the initial key as initial key

	Device thisDevice = Device.discover(deviceId, ConnectionDetails.BEARER_ETHERNET, 3, 2000);
	SuperA superA = new SuperA(RemoteAuthenticator.SUPERA_INITIAL_KEY, thisDevice);
Mirrors in the remote application the super administrator of the device. COnnection with the device is first established by the discovery procedure.

                        // object created
                User user = new User(admin, User.USER_ROLE_USER, "rigqa");
                user.updateKey("newSutta");
                user.syncroFields(user);
New user instance is created on the device by the administrator user admin: admin is an object instance of an administrator.  First action user perform is update its key and syncronizing his fields.

Remote authentication
Each time an user is created also other two objects are created and associated to user objects. They are the local administrator object and remote adinistrator object.
Remote administrator object (RAO) is in charge of enforcing security in the communication. It stores the keys that enforces security over communication guaranteeing integrity of messages, confidentiality and authentication of origin.
When user is created Administrators define an initial key used to iitially secure communication. Initial key is provided to users through a secure channel. User shall change the key at first access.
Each device has a different initial key for the super administrator

Local Authenticator
Local authenticator is in charge of user authentication through a PIN. Only user can set or change its own pin. Adminsitrator can unblock the pin in case it is blocked because retries due to wrong pin exceed maximum retries.

---------------------
System Logs
---------------------
IOT Briks logs system events and action performed on the device into a circular system log. 
Super Administrator have full access to the log including to System events.
Administrators have access to events relevants to his administration activities but do not have access to system logs.
User have access only to the events relevant to his activity.

FOllowing details are stored into the log:
- requesterId: User requesting the aciton if any.
- objectId: object on which the action is performed if any.
- event type
- result of operation;
- timestamp of the action;

	LogEntry le = DeviceLogger.getEntry(superA, index);
This command shows how superA get access to a log entry at position index. SUperA is a superA object.

	DeviceLogger.getLogCount(superA);
Returns the number of event stored in the log.

---------------------
Sensors.
---------------------
Sensors are probe objects. They allow users and remote application to measure values on input. Input can be phisical input of the board or values in input or output to digital funciton blocks. Sensors can be analog sensors, reading analog greatings, or digital sensors reading true or false.
A sensor is associated to an input identified by gpioId. Some gpioId identifies phisical gpios.

A sensor can also perform some data processing. For example can implement a Schmitt trigger on input data by defining low threshold and high threshold values to an analog sensor.

---------------------
Doors
---------------------

---------------------
Digital Function BLock
---------------------

---------------------
Finite State Machine
---------------------

---------------------
Weekly Policy
---------------------

